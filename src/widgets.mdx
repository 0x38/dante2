---
name: Widgets
---

import { Playground, PropsTable } from 'docz'
import {h1} from './site/data/poc.js'
import Dante from './editor/components/Dante/Dante.js'
import {State, Toggle} from 'react-powerplug'

# Widgets

Widgets are React components that are indeed blocks to be rendered in the editors text content. There are some blocks already implemented in dante2 

## Options
icon: This is the name
type: 
title
editable: element that should be editable
renderable: element that should be rendered
breakOnContinuous: this will enable the carriage return to exit the component or stay on it. This is usefull to handle the behavior on editable or non editable widgets.
block: The react class
wrapper_class: the style class that wraps your component
widget_options: a custom object that will be passed through the widget 


```
  widgets: [
    {
      icon: 'divider',
      type: 'divider',
      title: "Divider",
      editable: false,
      renderable: true,
      breakOnContinuous: true,
      block: DividerBlock,
      wrapper_class: "graf graf--hr",
      widget_options: {
        displayOnInlineTooltip: true,
        insertion: "insertion",
        insert_block: "divider"
      }
    },
    {
      title: 'add an image',
      icon: 'image',
      type: 'image',
      block: ImageBlock,
      editable: true,
      renderable: true,
      breakOnContinuous: true,
      wrapper_class: "graf graf--figure",
      selected_class: "is-selected is-mediaFocused",
      selectedFn: block => {
        const { direction } = block.getData().toJS()
        switch (direction) {
          case "left":
            return "graf--layoutOutsetLeft"
          case "center":
            return ""
          case "wide":
            return "sectionLayout--fullWidth"
          case "fill":
            return "graf--layoutFillWidth"
          default:
            return ""
        }
      },
      handleEnterWithoutText(ctx, block) {
        const { editorState } = ctx.state
        return ctx.onChange(addNewBlockAt(editorState, block.getKey()))
      },
      handleEnterWithText(ctx, block) {
        const { editorState } = ctx.state
        return ctx.onChange(addNewBlockAt(editorState, block.getKey()))
      },
      widget_options: {
        displayOnInlineTooltip: true,
        insertion: "upload",
        insert_block: "image"
      },
      options: {
        upload_url: '',
        upload_headers: null,
        upload_formName: "file",
        upload_callback: null,
        image_delete_callback: null,
        image_caption_placeholder: "type a caption (optional)"
      }
    }, {
      icon: 'embed',
      title: 'insert embed',
      type: 'embed',
      block: EmbedBlock,
      editable: true,
      renderable: true,
      breakOnContinuous: true,
      wrapper_class: "graf graf--mixtapeEmbed",
      selected_class: "is-selected is-mediaFocused",
      widget_options: {
        displayOnInlineTooltip: true,
        insertion: "placeholder",
        insert_block: "embed"
      },
      options: {
        //endpoint: `${options.oembed_uri}`,
        placeholder: 'Paste a link to embed content from another site (e.g. Twitter) and press Enter'
      },
      handleEnterWithoutText(ctx, block) {
        const { editorState } = ctx.state
        return ctx.onChange(addNewBlockAt(editorState, block.getKey()))
      },
      handleEnterWithText(ctx, block) {
        const { editorState } = ctx.state
        return ctx.onChange(addNewBlockAt(editorState, block.getKey()))
      }
    }, {
      icon: 'video',
      title: 'insert video',
      editable: true,
      type: 'video',
      block: VideoBlock,
      renderable: true,
      breakOnContinuous: true,
      wrapper_class: "graf--figure graf--iframe",
      selected_class: " is-selected is-mediaFocused",
      widget_options: {
        displayOnInlineTooltip: true,
        insertion: "placeholder",
        insert_block: "video"
      },
      options: {
        //endpoint: `${options.oembed_uri}`,
        placeholder: 'Paste a YouTube, Vine, Vimeo, or other video link, and press Enter',
        caption: 'Type caption for embed (optional)'
      },

      handleEnterWithoutText(ctx, block) {
        const { editorState } = ctx.state
        return ctx.onChange(addNewBlockAt(editorState, block.getKey()))
      },

      handleEnterWithText(ctx, block) {
        const { editorState } = ctx.state
        return ctx.onChange(addNewBlockAt(editorState, block.getKey()))
      }
    }, {
      renderable: true,
      editable: true,
      block: PlaceholderBlock,
      type: 'placeholder',
      wrapper_class: "is-embedable",
      breakOnContinuous: true,
      selected_class: "is-selected is-mediaFocused",
      widget_options: {
        displayOnInlineTooltip: false
      },

      handleEnterWithoutText(ctx, block) {
        const { editorState } = ctx.state
        return ctx.onChange(resetBlockWithType(editorState, "unstyled"))
      },

      handleEnterWithText(ctx, block) {
        const { editorState } = ctx.state
        const data = {
          provisory_text: block.getText(),
          endpoint: block.getData().get('endpoint'),
          type: block.getData().get('type')
        }
        return ctx.onChange(resetBlockWithType(editorState, data.type, data))
      }
    }
  ]
```